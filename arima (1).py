# -*- coding: utf-8 -*-
"""ARIMA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10XwHlEO0Z9BJ47Nmt6NubcNKU2hHuX37
"""

!pip install yfinance
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
plt.style.use('fivethirtyeight')
import seaborn as sns
import statsmodels as sm
import yfinance as yf
data = yf.download("AAPL MSFT TSLA", start="2020-01-01", end="2025-08-30")

import warnings
warnings.filterwarnings('ignore')

ticker = 'MSFT'
start_date = '2020-01-01'
end_date = '2025-09-30'
df = yf.download(ticker, start=start_date, end=end_date)

df.head()

df.tail()

df.info()

df.describe()

df.columns

df.index = pd.to_datetime(df.index)
df = df.sort_index()

print(df.isnull().sum())

plt.figure(figsize=(15,6))
plt.plot(df['Close'],label='MSFT Closing Price')
plt.title('MSFT Price Trend')
plt.legend()
plt.xlabel('Date')
plt.ylabel('Closing Prices')
plt.show()
plt.savefig('msft_price_trend.png', bbox_inches='tight')

target_col= df[['Close']].copy().astype(int) # converting data type to int
target_col.head(5)

from statsmodels.tsa.stattools import adfuller

result = adfuller(target_col['Close'])
print("ADF Statistic:", result[0])
print("p-value:", result[1])

target_col['Close_Diff'] = target_col['Close'].diff()

# Drop NaN created by differencing
diff_series = target_col['Close_Diff'].dropna()

# ADF Test
from statsmodels.tsa.stattools import adfuller

result = adfuller(diff_series)
print("ADF Statistic:", result[0])
print("p-value:", result[1])

target_col.head()

plt.figure(figsize=(15,6))
df['Close'].plot(kind='kde')

rolmean = target_col['Close'].rolling(12).mean()
rolstd = target_col['Close'].rolling(12).std()

plt.figure(figsize=(15,6))
plt.plot(target_col, color='blue')
plt.plot(rolmean, color='red', label='Rolling Mean')
plt.plot(rolstd, color='black', label='Rolling Std Dev')

plt.legend(loc='best')
plt.title('Rolling Mean and Standard Deviation')
plt.show()

from statsmodels.graphics.tsaplots import plot_acf, plot_pacf

plot_acf(df['Close'], lags=50)
plt.figure(figsize=(15,6))
plt.show()

plot_pacf(df['Close'], lags=50)
plt.figure(figsize=(15,6))
plt.show()

from statsmodels.tsa.seasonal import seasonal_decompose

decomposition = seasonal_decompose(df['Close'], model='multiplicative', period=252)  # ~252 trading days/year
decomposition.plot()
plt.figure(figsize=(15,6))
plt.show()

from statsmodels.graphics.tsaplots import plot_acf, plot_pacf

# Use log returns as the stationary series
log_ret = np.log(df['Close']).diff().dropna()

# ACF and PACF plots on logs of closing price
fig, ax = plt.subplots(1,2, figsize=(15,6))
plot_acf(log_ret, lags=40, ax=ax[0])
plot_pacf(log_ret, lags=40, ax=ax[1])
plt.show()

from statsmodels.tsa.arima.model import ARIMA

# Build ARIMA model (example with p=3, d=1, q=2)
model = ARIMA(df['Close'], order=(3,1,2))  # direct on price with differencing
model_fit = model.fit()

print(model_fit.summary())

train = df['Close'][:-365]
test = df['Close'][-365:]

# Fit ARIMA on training set
model = ARIMA(train, order=(3,1,2))  # adjust order after checking ACF/PACF
model_fit = model.fit()

# Forecast on test set length
forecast = model_fit.forecast(steps=len(test))

from sklearn.metrics import mean_squared_error, mean_absolute_error
import numpy as np

# Evaluation
rmse = np.sqrt(mean_squared_error(test, forecast))
mae = mean_absolute_error(test, forecast)

print("RMSE:", rmse)
print("MAE:", mae)

plt.figure(figsize=(15,6))
plt.plot(train.index, train, label='Train Data')
plt.plot(test.index, test, label='Actual Test Data', color='blue') # Plot the actual test data
plt.plot(test.index, forecast, label='ARIMA(3,1,2) Forecast', color='red', linestyle='--') # Plot the forecast
plt.legend()
plt.title("MSFT Closing Price: ARIMA Forecast vs Actual")
plt.xlabel("Date")
plt.ylabel("Closing Price ($)")
plt.grid(True)
plt.show()